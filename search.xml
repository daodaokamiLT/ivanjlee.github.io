<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java 8函数式数据处理]]></title>
    <url>%2F2017%2F12%2F27%2FJava-8_Stream%2F</url>
    <content type="text"><![CDATA[1 流1.1 流是什么流是Java 8中新引入的概念，它允许你以声明式方式处理数据集合（通过查询语句来表达，而不是临时编写一个实现）。 举个例子，筛选出价格大于¥50的菜品，并对这些菜品进行排序，最后返回菜品名称的集合，在Java 8之前： 123456789101112131415161718//第一步，筛选List&lt;Dish&gt; tempList = new ArrayList&lt;&gt;(dishes.size());for (Dish dish : dishes) &#123; if (dish.getPriceCent() &gt; 5000) &#123; tempList.add(dish); &#125;&#125;//第二步，排序Collections.sort(tempList, new Comparator&lt;Dish&gt;() &#123; public int compare(Dish d1, Dish d2) &#123; return d1.getPriceCent() - d2.getPriceCent(); &#125;&#125;);//第三步，返回名称集合List&lt;String&gt; result = new ArrayList&lt;&gt;(tempList.size())for (Dish dish : tempList) &#123; result.add(dish.getName());&#125; 在Java 8中，引入了流的概念之后，结合Lambda表达式： 12345List&lt;String&gt; result = dishes.stream() .filter(dish -&gt; dish.getPriceCent() &gt; 5000) .sorted(comparing(Dish::getPriceCent)) .map(Dish::getName) .collect(toList()); 流式方法的好处： 代码是以声明性方式写的，说明想要完成什么，而不是如何实现一个操作； 把几个基本操作链接起来，用以表达复杂的数据操作流水线，使代码清晰可读。 使用Java 8的Stream API可以写出这样的代码： 声明性——更简洁 ，更易读 可复合——更灵活 可并行——性能更好 1.2 流简介1.2.1 概念和术语Java 8中的集合支持一个新的stream方法，它会返回一个流，当然也有很多其他方法，比如利用数值范围或者I/O资源也可以生成流元素。 定义：从支持数据处理操作的源生成得元素序列。 关键概念： 术语 说明 元素序列 类似集合，流提供一个接口，可以访问特定元素类型的一组有序值。集合讲的是数据，流讲的是计算。 源 流会使用一个提供数据的源，比如集合、数组或者是I/O. 从有序集合生成流时会保留原有的序列。 数据处理操作 流的数据处理功能类似于数据库的操作，以及函数式编程语言中的常用操作，如filter、map、reduce、find、match、sort等。流操作可以顺序执行，也可以并行执行。 流水线 很多的流操作本身会返回一个流，这样多个操作就可以链接起来，形成一个流水线。 内部迭代 和使用迭代器进行显示迭代的集合不同，流的迭代操作是在背后进行的。 1.2.2 外部迭代与内部迭代使用Collection接口需要用户自己去做迭代，称为外部迭代。 使用Stream进行的迭代是内部迭代，Stream已经帮你把迭代做了，你只需要告诉它你需要干什么就可以了。 外部迭代： 内部迭代： 1.3 常见的流操作1.3.1 collect(toList)collect(toList)方法由Stream里的值生成一个列表。of方法可以生成一个流对象。 1List&lt;String&gt; list = Stream.of("a", "b", "c").collect(Collectors.toList()); 1.3.2 mapmap操作可以将一个流中的一种值转换成另一种类型的值，生成一个新的流(一对一映射)。比如，将一个集合中的字符串全部转换成大写。 12345678List&lt;String&gt; upperCaseList = Stream.of("talk", "is", "cheap", ",", "show", "me", "the", "code") .map(string -&gt; string.toUpperCase()) .collect(Collectors.toList());/* output: [TALK,IS,CHEAP,,,SHOW,ME,THE,CODE]*/ map操作传入的Lambda表达式必须和Function接口的签名一致。 123public interface Function&lt;T, R&gt; &#123; R apply(T t);&#125; 1.3.3 flatMapflatMap方法使一个流中的每个值都换成另外一个流，然后把所有的流都连接起来成为一个流（笛卡尔乘积）。 12345678910111213//找出两个数组中共同的元素，形成一个集合Integer[] array1 = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9&#125;;Integer[] array2 = &#123;2, 3, 5, 7, 11&#125;;List&lt;Integer[]&gt; list = Stream .of(array1) .flatMap(a1 -&gt; Stream.of(array2).filter(a1::equals).map(a2 -&gt; new Integer[]&#123;a1, a2&#125;)) .collect(Collectors.toList()); /* output: [&lt;2, 2&gt;, &lt;3, 3&gt;, &lt;5, 5&gt;, &lt;7, 7&gt;]*/ flatMap操作接收的Lambda表达式必须与Function接口的签名一致，传入的范型为Function&lt;? super T, ? extends Stream&lt;? extends R&gt;&gt;. 1.3.4 filterfilter用来遍历数据并选出符合特定条件的元素。比如筛选出一个字符串集合中仅含数字的字符串。 12345678List&lt;String&gt; digitList = Stream.of("a1c", "123", "1q2qw", "0.5") .filter(string -&gt; TextUtils.isDigitsOnly(string)) .collect(Collectors.toList()); /* output: [123]*/ 同样，filter操作传入的Lambda表达式必须和Predicate接口的签名一致。 123public interface Predicate&lt;T&gt; &#123; boolean test(T t);&#125; 1.3.5 distinctdisdint方法会返回一个元素各异的流，简单来说，就是滤重（根据元素的hashCode和equals方法）。 12345678List&lt;Integer&gt; distinctList = Stream.of(1, 1, 2, 2, 3, 3, 3, 4) .distinct() .collect(Collectors.toList()); /* output: [1,2,3,4]*/ 1.3.6 limitlimit(n)会返回一个不超过给定长度的流。如果流是有序的，则最多会返回前n个元素。 12345678List&lt;Integer&gt; list = Stream.of(1, 2, 3, 4, 5, 6, 7) .limit(3) .collect(Collectors.toList()); /* output: [1,2,3]*/ 1.3.7 skipskip(n)，会返回扔掉前n个元素的流，如果流中元素不超过n，则会返回一个空的流。 12345678List&lt;Integer&gt; list = Stream.of(1, 2, 3, 4, 5, 6, 7) .skip(3) .collect(Collectors.toList()); /* output: [4,5,6,7]*/ 1.3.8 min和max求最小值和求最大值。比如求菜品集合中价格最低和最高的菜。 12345678List&lt;Dish&gt; dishes = ...Dish max = dishes.stream() .max(Comparator.comparing(dish -&gt; dish.getPrice)) .get(); Dish min = dishes.stream() .mix(Comparator.comparing(dish -&gt; dish.getPrice)) .get(); 1.3.9 reducereduce操作可以从一组值中生成一个值，实际上max和min也是reduce操作，因为太常用，所以被纳入了标准库中。举例，求和： 12int sum = Stream.of(1, 2, 3, 4) .reduce(0, (acc, element) -&gt; acc + element); reduce对应的操作有3个重载的方法： 123456789101112131415//无初始值的Optional&lt;T&gt; reduce(BinaryOperator&lt;T&gt; accumulator);//等价于boolean foundAny = false;T result = null;for (T element : this stream) &#123; if (!foundAny) &#123; foundAny = true; result = element; &#125; else &#123; result = accumulator.apply(result, element); &#125;&#125;return foundAny ? Optional.of(result) : Optional.empty(); 12345678//带初始值的T reduce(T identity, BinaryOperator&lt;T&gt; accumulator);//等价于T result = identity;for (T element : this stream) result = accumulator.apply(result, element)return result; 12345678910//参数带两个BiFuction的&lt;U&gt; U reduce(U identity, BiFunction&lt;U, ? super T, U&gt; accumulator, BinaryOperator&lt;U&gt; combiner); //等价于U result = identity;for (T element : this stream) result = accumulator.apply(result, element)return result; 1.3.10 anyMatch、allMatch和noneMatchanyMatch判断流中是否至少有一个元素能匹配给定的条件，返回一个boolean值。 12boolean hasNullElements = Stream.of("Java", "Python", "C#", null, "Ruby", "Go", "Object C") .anyMatch(Objects::isNull); allMatch检查流中流中所有元素是否匹配给定的条件，返回boolean值。 noneMatch检查流中所以元素是否都不匹配给定的条件，返回boolean值。 1.3.11 findAny与findFirstfindAny找到流中任意一个元素(通常是第一个)，返回一个Optional对象，如果流是空的，返回一个值为空的Optional对象，如果找到的元素刚好是空值，则抛出一个NullPointerException。 1234public final class Optional&lt;T&gt; &#123; T t; //...&#125; 例： 1234Optional&lt;Integer&gt; optional = Stream.of(1, 2, 3, 4, 5, 6, 7) .findAny(); //执行多次optional.get()始终是1 如果使用的是并行的流，那么findAny方法返回的值则是不确定的，比如下面的例子： 1234567891011121314151617181920212223List&lt;Integer&gt; array = Arrays.asList(1, 2, 3, 4, 5, 6, 7);Printer.println(array.parallelStream().findAny().get());Printer.println(array.parallelStream().findAny().get());Printer.println(array.parallelStream().findAny().get());Printer.println(array.parallelStream().findAny().get());/* 执行多次返回值分别是：第1次：5555Process finished with exit code 0第2次：4726Process finished with exit code 0*/ findAny操作一般和filter结合起来用，用于筛选。 如果想始终找到第一个元素，则应该用findFirst操作，即使是并行的流，页始终能返回第一个元素。 短路求值：对于有些操作，不必处理整个流就能得到结果，就像用 || 连接起来的布尔表达式求值一样，只要提前找到一个为true的值就直接返回。流的操作中，anyMatch、findAny、findFirst都是短路操作，limit也是。 1.4 流与集合1.4.1 流与集合概念的差异从前面的例子中可以看到，通过Stream.of(…)方法可以得到一个流对象，看起来数据源似乎是保存在了流对象中，这和集合中保存一组数据很类似。但是，最终从流中获取一个集合，还需要调用collect(toList())方法，由此可见，流并不是集合。 流与集合到底有什么差异呢？举一个形象的例子，存在DVD中的电影，这就是一个集合，因为它包含了电影的全部数据，而网上在线播放的视频则是一个视频流，它只加载你当前观看的这几帧，不用等到所有的数据都加载完了才能看。 所以简单来讲，集合与流之间的差异就在于何时进行计算。集合是内存中的一种数据结构，它包含了数据源的所有值，集合的每个元素都需要先计算出来然后再加入到集合中。而流的元素则是按需计算，仅仅在用户需要的时候才会提取值，这是一种生产者—消费者的关系，只有消费者要求的时候才会去计算值。 1.4.2 流只能遍历一次和迭代器类似，流只能遍历一次，遍历完成之后，这个流就已经被消费掉了。如果想再次遍历，需从数据源重新获取一个流（如果数据源是可重复的比如集合，这会很容易，但如果像I/O这种的话，就会很麻烦）。 重复消费一个流会抛出IllegalArgumentException，表示流已经被操作，或者关闭。 1234List&lt;String&gt; firms = Arrays.asList(&quot;Google&quot;, &quot;AT&amp;T&quot;, &quot;Amazon&quot;, &quot;Facebook&quot;, &quot;Oracle&quot;, &quot;MicroSoft&quot;);Stream&lt;String&gt; stream = Stream.of(firms);stream.forEach(System.out::println);stream.forEach(System.out::println); 1.5 流的构建1.5.1 数值流在有些流的操作中，流中的元素如果是数值，会不可避免的产生装箱和拆箱的操作，比如，对菜品的价格求和： 123456789101112131415161718List&lt;Dish&gt; dishes ...int sumPrice = dishes.stream() .map(Dish::getPrice) .reduce(0, Integer::sum);``` 这段代码中，map操作会生成一个Stream&lt;T&gt;的流，因此，就需要将int类型装箱成Integer。在Java 8的Stream API中，为了避免这种拆装箱，提供了原始类型流特化，专门支持处理数值流。#### 1.5.1.1 原始类型流特化Java 8中引入的原始类型流特化流有3个：IntStream、LongStream和DoubleStream，分别将流的元素特化为对应的基础类型。相应的这些流中也多了一些常用的数值操作，比如sum, average, max, min等。将流转化成特定的数值流常用的操作是map，对应的，map操作也有几个特定的方法，mapToInt、mapToLong、mapToDouble。比如上面对菜品价格求和的操作，就可以用IntStream来做：```JavaList&lt;Dish&gt; dishes ...int sumPrice = dishes.stream() .mapToInt(Dish::getPrice) .sum; 有时候，也会有将数值流转回对象流的需求，这时候只需要将基础元素进行装箱操作就可以，使用的操作是boxed。 123IntStream intSream = dishes.stream() .mapToInt(Dish::getPrice);Stream&lt;Integer&gt; stream = intStream.boxed(); 上面讲findAny和findFirst操作的时候，提到了Optional对象，类似的，Optional类也对数值的基础类型进行了特化，有IntOptitonal、LongOptional和DoubleOptional三个类。 1.5.1.2 数值范围Java 8引入了两个可以用于InStream和LongStream的静态方法，range和rangeClose。区别是range不包含结束值，rangeClosed包含结束值。 1234567IntStream intStream = IntStream.range(1, 10); int[] array = intStream.toArray(); Printer.print(array);/* output: [1,2,3,4,5,6,7,8,9]*/ 123456IntStream intStream = IntStream.rangeClosed(1, 10); int[] array = intStream.toArray(); Printer.print(array);/* output: [1,2,3,4,5,6,7,8,9,10] 1.5.2 构建流的几种方式1.5.2.1 由值创建流使用Stream.of(T t …)方法可以创建出一个流，Stream.empty()可以创建一个没有元素的流： 12Stream&lt;String&gt; stringStream = Stream.of("Apple", "MicroSoft", "Google", "Facebook", "Amazon");Stream&lt;String&gt; emptyStream = Stream.empty(); 1.5.2.2 由数组创建流Arrays.stream可以从数组创建一个流，参数是一个数组。 123456String[] stringArray = &#123;"Apple", "MicroSoft", "Google", "Facebook", "Amazon"&#125;;int[] intArray = &#123;0, 1, 1, 2, 3, 5, 8, 13, 21&#125;; Stream&lt;String&gt; stringStream = Arrays.stream(stringArray);IntStream intStream = Arrays.stream(intArray);Stream&lt;Integer&gt; integerStream = Arrays.stream(intArray).boxed(); 1.5.2.3 由集合生成流Java的Collection接口中，引入了stream()和parallelStream()两个默认方法，可以生成流。 1234String[] stringArray = &#123;"Apple", "MicroSoft", "Google", "Facebook", "Amazon"&#125;;List&lt;String&gt; list = Arrays.asList(stringArray);Stream&lt;String&gt; stream = list.stream();Stream&lt;String&gt; parallelStream = list.parallelStream(); 1.5.2.4 由文件生成流Java 8的NIO API中，很多操作都可以返回一个流。比如，Files.lines就会根据文件内容返回一个流。 1234567try &#123; Stream&lt;String&gt; lines = Files.lines(Paths.get(".gitignore"), Charset.forName("utf-8")) .flatMap(line -&gt; Arrays.stream(line.split(" "))); lines.forEach(word -&gt; Printer.println(word)); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; 1.5.2.5 由函数生成流：创建无限流Stream API中提供了2个静态方法来从方法中生成流：Stream.iterate和Stream.generate，这2个方法都可以用来创建无限流，只要不结束，可以一直算下去。 iterate iterate方法有两个重载的方法： 12//有结束条件的public static&lt;T&gt; Stream&lt;T&gt; iterate(T seed, Predicate&lt;? super T&gt; hasNext, UnaryOperator&lt;T&gt; next) 和 12//没有限制，可以真正生成无限流public static&lt;T&gt; Stream&lt;T&gt; iterate(final T seed, final UnaryOperator&lt;T&gt; f) 例如，生成一个斐波那契数列： 1234Stream.iterate(new int[]&#123;0, 1&#125;, t -&gt; new int[] &#123;t[1], t[0] + t[1]&#125;) .map(t -&gt; t[0]) .limit(20) .forEach(Printer::println); generate 和iterate方法类似，generate也生成一个无限流。 1public static&lt;T&gt; Stream&lt;T&gt; generate(Supplier&lt;? extends T&gt; s) generate方法的参数是一个Supplier，它可以是无状态的，也可以是有状态的。 无状态的Supplier，不会记录上一个状态，比如生成随机数， 123Stream.generate(Math::random) .limit(20) .forEach(Printer::println); 有状态的Supplier还可以是有状态的，它会记录前一个Supplier的状态（可以是值，属性等），比如还是生成一个斐波那契数列，在构建每一个元素时，都改变了supplier的属性： 12345678910111213141516IntSupplier supplier = new IntSupplier() &#123; private int pre = 0; private int cur = 1; @Override public int getAsInt() &#123; int oldPre = pre; int oldCur = cur; this.pre = cur; this.cur = oldPre + oldCur; return oldPre; &#125; &#125;; IntStream.generate(supplier) .limit(20) .forEach(Printer::println); Author: Ivan J. LeeDate : 2017-12-27 23:56]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 8函数式编程–––Lambda表达式]]></title>
    <url>%2F2017%2F11%2F28%2FJava-8_Lambda%2F</url>
    <content type="text"><![CDATA[1. 介绍1.1 匿名内部类设计匿名内部类的目的，是为了方便开发者将代码作为数据传递。举个栗子，在Android中，为一个按钮设置一个点击事件的监听器： 12345button.setOnClickListener(new View.OnClickListener() &#123; public void onClick(View view) &#123; Log.v(TAG, "button is clicked!"); &#125;&#125;); 1.2 Lambda表达式Lambda表达式的作用和匿名内部类相似，也是为了将代码作为数据来传递，从某种意义上讲，Lambda表达式也可以理解为匿名函数，在其他的一些语言中则把称为闭包，实际上意义都差不多的。上面的例子，用Lambda表达式来改写，可以表示为： 1button.setOnClickListener(view -&gt; Log.v(TAG, "button is clicked!")); 和使用匿名内部类传入实现了某个接口的对象不同，Lambda传入的参数是一段代码快，即匿名函数(注意这里已经不在叫方法而叫函数了)。这个匿名函数中，-&gt;将参数和Lambda表达式的主体分开，view是函数的参数，Log.v(TAG, “button is clicked!”)是这个函数的具体实现。 lambda表达式语法： 1(parameters) -&gt; expression 或者 1(parameters) -&gt; &#123;statemens;&#125; Lambda表达式中，参数的类型不需要显式指明，因为javac会根据程序的上下文来推断出参数的类型，这一点和kotlin很相似。 几个Lambda表达式的例子： 1、没有参数 123456Runnable runnable = () -&gt; Log.v(TAG, "run");``` 2、一个参数```javaView.OnClickListener listener = view -&gt; Log.v(TAG, "onClick"); 3、一个参数包含代码块 1234Runnable runnable = () -&gt; &#123; Log.v(TAG, "run first step"); Log.v(TAG, "run second step"); &#125; 4、多个参数,不指定参数类型 1Callback&lt;String&gt; callback = (arg1, arg2) -&gt; arg1 + arg2; 5、多个参数指定类型 1Callback&lt;String&gt; callback = (String str1, String str2) -&gt; str1 + str2; Lambda表达式的参数类型虽然可以由编译器推断出来, 但是在某些情况下, 也可能会推断不出来, 这时候就需要显式声明参数的类型了. 1.3 引用值而非变量在匿名内部类中，如果需要引用外部的局部变量，则必须将这个变量设置成final类型，比如 123456final String name = getUserName();button.setOnClickListener(new View.OnClickListener() &#123; public void onClick() &#123; Toast.make(context, "hi, " + name, Toast.LENGTH_LONG).show(); &#125;&#125;); 为什么匿名内部类访问局部变量必须是final类型的呢？简单来说，是为了保证数值的一致性。局部变量和匿名内部类的生命周期是不一样的，如果匿名内部类直接使用局部变量的引用并修改其值，则有可能造成内外值不一致的情况，所以Java规定了匿名内部类只能引用final类型的局部变量，这样一来，值不会被真正改变，匿名内部类中，也就保证了值的一致性。 在Java 8中，放松了这一限制，可以引用非final类型的变量，然而，该变量在既成事实上也必须是final类型的。 在Lambda表达式中，实际上也只能使用final类型的局部变量，即便不加final关键字，这个变量也还是final类型的。如果试图给Lambda表达式中使用一个非final类型的变量，编译器将会报错。 1234//这段代码不能通过编译String name = getFirstName();name = "Mr. " + name;button.setOnClickListener(view -&gt; Toast.make(context, "Hi, " + name, Toast.LENGTH_LONG).show()); 2 Lambda表达式的应用2.1 函数式接口函数接口（Functional Interface）是只有一个抽象方法的接口。例如： 123public interface Comparator&lt;T&gt; &#123; int compare(T o1, T o2);&#125; 及 123public interface Runnable &#123; void run();&#125; 注意：Java 8中，接口可以有默认方法，即便一个接口定义了多个默认方法，只要它的抽象方法只有一个，它仍然是一个函数式接口。 Lambda表达式与函数式接口有什么关系呢？引用书中的一句话： Lambda表达式允许你直接以内联的形式为函数式接口的抽象方法提供实现，并把整个表达式作为函数式接口的实例（具体来说，是函数式接口一个具体实现的实例）。 通俗一点来讲，Lambda表达式为函数式接口提供了具体的实现，从而来实现Java方法的传递（或者说是代码块传递）。当然，匿名内部类也可以实现同样的功能，只不过使用匿名内部类使用起来非常笨拙。 @FunctionalInterface注解用于表示一个接口被设计为了函数式接口。如果自定义的接口加了这个注解，但确不是函数式接口，IDE会在编译时报错，“Multiple non-overriding abstract methods found in interface Foo”，意思是Foo这个接口中有多个抽象方法。 对于函数式接口的设计，@FunctionalInterface并非是必须的，但是加上它是一个好习惯。 2.2 函数描述符函数式接口中抽象方法的签名基本上也就是Lambda表达式的签名，我们把这种抽象方法叫做函数描述符。 比如Runnable接口可以看作是一个什么也不接收，什么也不返回的方法的签名，它的run()方法不接收任何参数，最终返回void. Lambda和函数式接口的方法签名的一种记法： 1() -&gt; void 这里表示的是Runnable接口所代表的方法。 到此为止，关于Lambda表达式，我们需要记住的是： 1. Lambda表达式可以赋值给一个变量(函数式接口)；2. Lambda表达式可以传递给一个接收函数式接口的方法。 例子：Lambda表达式的有效使用方式： (1) Lambda表达式传给一个接收函数式接口的方法 12345execute(() -&gt; &#123;&#125;);public void execute(Runnable r)&#123; r.run(); &#125; 这里的Lambda表达式的签名是-> void```，这是Runnable接口所代表的方法。1234567891011(2) Lambda表达式作为返回值```javapublic Callable&lt;String&gt; fetch() &#123; return () -&gt; &quot;Tricky example ;-)&quot;;&#125;interface Callable&lt;T&gt; &#123; T call();&#125; fetch()方法返回一个Callable对象，Callable所代表的方法是-> String```，这和例中所用的签名是一致的。123456789(3) 一种错误的用法```javaPredicate&lt;Apple&gt; p = (Apple a) -&gt; a.getWeight();interface Predicate&lt;T&gt; &#123; boolean test(T t);&#125; 例中Lambda表达式的签名是-> Double```，Predicate所代表的方法是```(Apple) -> boolean```，不一致。1234567891011121314### 2.3 函数式接口的使用上面介绍了函数式接口和函数描述符的概念，为了应用不同的Lambda表达式，就需要一套能够描述常见函数描述符的函数式接口。Java 8的java.util.function包中为我们引入了很多函数式接口。几个典型的函数式接口如下：#### 2.3.1 Predicate```java@FunctionalInterfacepublic interface Predicate&lt;T&gt;&#123; boolean test(T t); ...&#125; 涉及到返回值是boolean类型的表达式时，可以用Predicate，例如： 1Predicate&lt;String&gt; p = (s) -&gt; !s.isTempty(); 2.3.2 Consumer12345@FunctionalInterfacepublic interface Consumer&lt;T&gt;&#123; void accept(T t); ...&#125; 需要对一个对象进行访问可以用Consumer，例如： 123456789//定义一个forEach方法public void &lt;T&gt; forEach(List&lt;T&gt; list, Consumer&lt;T&gt; consumer) &#123; for (Integer i : list) &#123; consumer.consume(i); &#125;&#125;//使用forEach(Arrays.asList(1,2,3,4,5), (Integer i) -&gt; System.out.print(i)); 2.3.3 Function 12345@FunctionalInterfacepublic interface Function&lt;T, R&gt;&#123; R apply(T t); ...&#125; 创建映射关系或者从一个对象中提取信息可以用Function&lt;T, R&gt;。 3 类型检查与类型推断上面提到，Lambda表达式为函数式接口提供了实现，但是Lambda表达式本身并不包含实现了哪个函数式接口的任何信息，所以需要了解Lambda表达式的实际类型。 3.1 类型检查Lambda表达式需要的类型称为目标类型。只要函数签名一致，Lambda表达式可以与很多函数式接口相关联。 一张图说明类型检查的过程： 1List&lt;Apple&gt; heavierThan150g = filter(inventory, (Apple a) -&gt; a.getWeight() &gt; 150); 3.2 类型推断类型推断是Java 7引入的概念，&lt;&gt;操作符可使编译器在编译时根据上下文推断出参数类型。 1HashMap&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); 这里，声明map时，已经明确指定了范型的类型，所以在new出HashMap对象时，编译器已经知道HashMap的具体范型。 Java 8中，Lambda表达式可以省略所有参数的类型。因为函数描述符可以通过目标类型来得到，所以Java编译器就可以通过上下文信息来推断出正确的参数类型，从而确定使用什么函数式接口来配合Lambda表达式。 当然，Lambda表达式也可以不省略参数类型，显式指定。至于这两种方式哪一种更好呢，则取决于不同的场景，有时候省略参数类型代码更易读，有的时候显式指明参数类型则比较好。 4 方法引用4.1 方法引用简介既然Lambda表达式可以与函数式接口相关联，作为函数式接口的函数描述符的引用，那么一个对象的方法有没有类似的表示方法呢？答案是有的，Java 8提供了方法引用(Method Referen)的表示方法。（在C语言或者是其他一些编程语言中，也有类似的概念，比如，C语言中的指向函数的指针，Python中把一个函数赋值给变量） 方法引用可以重复使用现有的方法定义，并像Lambda表达式一样传递它们。 方法引用通过一个::来表示，需要使用方法引用时，目标引用放在分隔符::前，方法名放在后面。 一些例子： Lambda 方法引用 () -&gt; Thread.currentThread().dumpStack() Thread.currentThread()::dumpStack (str, i) -&gt; str.substring(i) String::substring (String s) -&gt; System.out.print(s) System.out::print 4.2 构建方法引用4.2.1 方法引用主要分为3类： 指向静态方法引用 例如Integer.parseInt()方法，写作Integer::parseInt 指向任意类型方法实例的方法引用 如String中的length方法，写作String::length 指向已有对象的实例方法的方法引用 比如有一个Student的实例stu，有一个方法是getName，就可以写成stu::getName 区别： 静态方法引用是直接引用类的静态方法，通过 “类名::方法名”的方式引用； 第二种方法引用中，引用了一个对象的方法，但是这个对象本身是Lambda表达式的一个参数，不如上面的例子中，对应的Lambda表达式是(String s) -&gt; s.length()； 第三种中，是在Lambda表达式中调用一个已经存在的对象的方法，上面的例子改写成Lambda表达式就是() -&gt; stu.getName()，和第二种的区别就是调用的对象的方法不是Lambda的参数。 4.1.2 构造方法引用对于一个现有的构造方法，可以利用它的名称和关键字new来创建一个方法引用：ClassName::new. 它的功能和静态方法的引用类似，比如有一个无参构造方法，适合Supplier的签名，() -&gt; Apple，那么可以这样写： 12Supplier&lt;Apple&gt; constuctor = Apple::new;Apple apple = constructor.get(); 它等价于Lambda表达式的写法： 12Supplier&lt;Apple&gt; constuctor = () -&gt; new Apple();Apple apple = constructor.get(); 5 实践有一些菜品，存在dishes```中，现在要将它们按照价格升序排序。1234567891011121. 在Java 8之前 Java 8之前，List没有sort方法，需要借助Collection类。 ```Java public class DishComparator implements Comparator&lt;Dish&gt; &#123; public int compare(Dish d1, Dish d2) &#123; return d1.getPrice() - d2.getPrice(); &#125; &#125; Collection.sort(list, new DishComparator()); Java 8中，使用来排序list Java 8之前，List没有sort方法，需要借助Collection类。 123456public class DishComparator implements Comparator&lt;Dish&gt; &#123; public int compare(Dish d1, Dish d2) &#123; return d1.getPrice() - d2.getPrice(); &#125;&#125;list.sort(new DishComparator()); 使用匿名内部类 12345list.sort(new Comparator&lt;Dish&gt; &#123; public int compare(Dish d1, Dish d2) &#123; return d1.getPrice() - d2.getPrice(); &#125;&#125;); 使用Lambda表达式 1list.sort((Dish d1, Dish d2) -&gt; d1.getPrice() - d2.getPrice()); 使用方法引用 1list.sort(Comparator.comparating(Dish::getPrice)) 6 小结 Lambda表达式可以理解为一种匿名函数：没有名称，但有参数列表、函数主体、返回值； Lambda表达式可以让你更简洁的传递代码； 函数式接口就是仅仅声明了一个抽象方法的接口； 只有在接收函数式接口的地方才可以使用Lambda表达式； Lambda表达式允许你直接内联，为函数式接口的抽象方法提供实现，并且将整个表达式作为函数式接口的的一个实例； Java 8自带一些常用的函数式接口，在java.util.function包里，包括Predicate、Function&lt;T,R&gt;、Supplier、Consumer等； Lambda表达式所需要的代表的类型成为目标类型； 方法引用让你重复使用现有的方法实现并直接传递它们； Comparator、Predicate、和Function等函数式接口有几个可以结合Lambda表达式的默认方法。 – 作者：Ivan J. Lee时间：2017-11-28 00:40]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git常用命令]]></title>
    <url>%2F2017%2F06%2F08%2Fgit%2F</url>
    <content type="text"><![CDATA[本文出处https://zhuanlan.zhihu.com/p/25415162 或者 http://blog.csdn.net/u013301192/article/details/69568557 Git作为一种常用的现代版本管理工具，应用的十分广泛，作为开发者，Git是一项必不可少的技能，掌握常见的Git命令能够大大提高我们的工作效率。 这里只介绍最基础的，最常用的命令，配置相关的东西直接略过，git相关的一些概念也不介绍了。在执行下面的命令的时候，假定你已经安装好了git，并且在你的远程git仓库的网站上添加了你的key，建立了安全的连接。以下所有的命令基于Mac OS X 10.12，Git版本2.10.1 (Apple Git-78)。 基本命令下载项目拿到项目的git地址，比如这个git@github.com:IvanJLee/git.git，新建一个文件夹，把代码下载下来：123mkdir LearningGitcd LearningGitgit clone git@github.com:IvanJLee/git.git 等待代码下载完成，LearningGit目录下，多出了一个git文件夹，这个文件夹中就是上面那个仓库的所有文件了。进入git文件夹，查看所有文件，会发现有一个.git文件夹，这就是Git的版本库了。 有时候是在本地新建的项目，想上传到远程的仓库，在项目的根目录下，初始化git仓库：1git init 查看远程仓库：1git remote -v 添加一个远程仓库：1git remote add origin-name git@github.com:IvanJLee/git.git 个人信息的配置一般一个项目，提交代码的时候都会提前配置好个人信息，以便查看提交的作者信息。没有配置的时候，名字默认是取的是操作系统的当前用户的名字。 查看配置信息：1git config --list 设置用户名和邮箱（全局的配置加上–global，只是当前项目的话，就不要了，这里一般当前项目没有配的话，就用的是全局的配置。为什么要有两个呢，比如有这样的场景，我的笔记本是公司给配的 ，git的全局配置是真名和公司邮箱，但有时候，我会写一些自己的代码，上传到GitHub上，用的是我的昵称和私人邮箱，所以个人的项目就进行单独的配置）：12git config (--global) user.name &quot;Ivan&quot;git config (--global) user.mail &quot;lijundut@foxmail.com&quot; 当然修改配置除了上述方法之外，还可以直接改配置文件，可以改的很多，绝对不止用户名和邮箱，修改当前项目的配置的话直接编辑.git/config文件；修改当前用户的配置，编辑~/.gitconfig；修改整个操作系统的配置，编辑/etc/gitconfig. 提交代码对项目中的文件作出修改或删除，或者新建文件之后，查看哪些文件有修改： 1git status Changes not staged for commit是对项目中已有的文件作出的修改，Untracked files是新建的文件，尚未加到版本库中。 查看具体有哪些修改，查看全部文件的：1git diff 或者，查看单个文件： 1git diff README.md 将需要提交的文件加到待提交列表（支持正则表达式），比如把README.md加进去： 1git add README.md 或者把所有修改过的文件全部加进去： 1git add * 提交修改到本地暂存区： 1git commit -m &apos;my commit message&apos; 或者，使用其它的文本编辑器编辑提交信息（输完下面的命令后，会自动跳过去，Mac OX的终端中默认用vim）： 1git commit 提交修改到远程分支（这时候可能别人已经修改了代码，你的push会被拒绝，先pull一下就可以了）： 1git push 获取远程的修改Git是协同工作的工具，我们自己在修改的同时，别人也在修改，那么获取别人的修改就有了一下的命令。 获取远程仓库的修改： 1git fetch 获取远程仓库的修改，并合并到本地分支： 1git pull 有多个远程仓库的话： 12git pull origin1git pull origin2 简单来说，pull = fetch + merge，详细区别请看git pull与fetch的区别 分支管理一般来说，刚拉下来的项目代码都是在master分支上，绝大多数情况下，master分支是受保护的分支，不允许直接提交代码，这也是我们在使用Git时应当注意的。master分支在任何情况下都是禁止直接提交代码的。 查看本地分支： 1git branch 查看远程分支： 1git branch -r 查看全部分支： 1git branch -a 基于当前所在的本地分支创建一个新分支（比如当前在master分支，执行下面的命令后切到了my-develop分支，但在my-develop分支上push代码到远程仓库仍然是提交到master分支上的）： 1git checkout -b my-develop 基于远程分支创建一个新分支（也是创建一个新的分支，但是和上面不同的是，在my-branch上push代码会提交到远程的develop分支上）： 1git checkout -b origin/develop my-branch 切换到本地的另外一个分支上，比如develop-ivan（如果这个分支不存在，会报错，加上参数-b创建新的分支）： 1git checkout develop-ivan 给分支改名： 1git branch -m old-branch-name new-branch-name 把本地分支提交到远程仓库： 1git push origin -u local-branch-name:remote-branch-name 上面的一条命令等同于下面的两条命令： 12git push origin local-branch-name:remote-branch-namegit branch --set-upstream-to=origin/remote-branch-name local-branch-name 删除一个本地分支，比如删除my-branch分支： 1git branch -d my-branch 如果本地有commit，无法删除，删除本地本地分支以及此分支上的commit： 1git branch -D my-branch 删除一个远程分支，比如develop-lee分支(没有直接删除远程分支的命令，使用push命令，本地分支名为空就可以了)： 1git push origin :develop 合并其他分支的代码到当前分支： 1git merge other-branch-name 或： 1git rebase other-branch-name merge和rebase的功能基本相似，都是合并代码，区别是rebase会把git提交的时间线压平，提交的时间线看起来会更加整洁，但是不建议这么做，一般建议使用merge。git中merge和rebase的区别查看提交信息查看当前分支的commit信息： 1git log 查看每次commit修改的文件： 1git log --stat 按关键字筛选commit信息： 1git log -S keyword 按作者筛选commit信息，支持正则： 1git log --author = &quot;Ivan&quot; 暂存代码有时候，正在自己的分支上开发，突然出现了线上bug，需要去其他分支修复，当前的分支功能又没有开发完毕，你还不想提交未完成的代码，这时候使用stash命令就会很方便。stash命令可以把修改的代码都存在本地，而不commit，之后回来可以恢复之前的修改。常用的stash命令如下： 查看保存的修改： 1git stash list 查看某一个stash修改的具体内容： 1git stash show -p stash@&#123;1&#125; 查看某一个stash修改的文件： 1git stash show stash@&#123;0&#125; 保存当前的修改： 1git stash save &quot;save message&quot; 或者，自动填写stash message： 1git stash 删除某一次stash： 1git stash drop stash@&#123;1&#125; 或者删除最近的一次stash： 1git stash drop 恢复最近一次stash： 1git stash pop 恢复某一次stash： 1git stash pop stash@&#123;1&#125; 删除全部的stash： 1git stash clear 其他常见命令恢复一个文件的修改（和切换分支一样，也是checkout）: 1git checkout file_name 把提交的文件回滚到某一次提交（先用git log查看提交记录，找到某次提交的sha1值，使用git reset回到某次提交，其中soft表示保留新的修改但取消git add，mixed表示保留修改和git add，hard表示不保留修改）： 12git loggit reset --(soft|mixed|hard) 3275a0c85fb2fbbcd6eaa65be1f956d27fa9998b 使用git add命令，把文件加到要提交的列表中后，把它待提交列表中移除： 1git reset --HEAD filename 把一个文件从版本库中移除： 1git rm filename 更多应用以上只是Git使用的最基本命令，掌握这些命令，工作中Git操作大部分已经没有问题。当然，Git的功能是很强大的，所能做的事情也远远不止这些，要全面掌握Git的技巧，一两篇文章是说不清楚的。当然，熟悉Git最好的方法就是去实践，学以致用，用的多了自然就记得住。 查看所有的Git命令，可以详细了解每一条命令以及加参数的用法： 1git --help 要想系统学习Git，可以找到的资源有很多，下面是一些学习Git的不错的网站。 Pro git: git–distributed-is-the-new-centralized，简体中文版：Pro Git 廖雪峰的Git教程 learngitbranching以游戏的方式学习Git]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Welcome]]></title>
    <url>%2F2017%2F06%2F08%2Ffirst_page%2F</url>
    <content type="text"><![CDATA[Welcome About Me]]></content>
      <categories>
        <category>other</category>
      </categories>
      <tags>
        <tag>other</tag>
        <tag>test</tag>
      </tags>
  </entry>
</search>
